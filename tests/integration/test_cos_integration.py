#!/usr/bin/env python3
# Copyright 2024 Canonical Ltd.
# See LICENSE file for licensing details.

import asyncio
import inspect
import logging
import os
import subprocess
from pathlib import Path

import pytest
from juju.controller import Controller
from pytest_operator.plugin import OpsTest
from utils import get_or_add_model

logger = logging.getLogger(__name__)


def get_this_script_dir() -> Path:
    filename = inspect.getframeinfo(inspect.currentframe()).filename  # type: ignore[arg-type]
    path = os.path.dirname(os.path.abspath(filename))
    return Path(path)


@pytest.mark.abort_on_fail
async def test_setup_and_deploy(ops_test: OpsTest, series, channel):
    """Setup models and then deploy Hardware Observer and COS."""
    lxd_ctl_name = os.environ["LXD_CONTROLLER"]
    k8s_ctl_name = os.environ["K8S_CONTROLLER"]

    # The current model name is generated by pytest-operator from the test name + random suffix.
    # Use the same model name in both controllers.
    k8s_mdl_name = lxd_mdl_name = ops_test.model_name

    # Assuming a lxd controller is ready and its name is stored in $LXD_CONTROLLER.
    lxd_ctl = Controller()
    await lxd_ctl.connect(lxd_ctl_name)
    lxd_mdl = await get_or_add_model(ops_test, lxd_ctl, lxd_mdl_name)
    await lxd_mdl.set_config({"logging-config": "<root>=WARNING; unit=DEBUG"})

    # Assuming a k8s controller is ready and its name is stored in $K8S_CONTROLLER.
    k8s_ctl = Controller()
    await k8s_ctl.connect(k8s_ctl_name)
    k8s_mdl = await get_or_add_model(ops_test, k8s_ctl, k8s_mdl_name)
    await k8s_mdl.set_config({"logging-config": "<root>=WARNING; unit=DEBUG"})

    await _deploy_cos(channel, k8s_mdl)

    await _deploy_hardware_observer(series, channel, lxd_mdl)

    await _add_cross_controller_relations(k8s_ctl, lxd_ctl, k8s_mdl, lxd_mdl)


async def _deploy_cos(channel, model):
    """Deploy COS on the existing k8s cloud."""
    await model.deploy(
        "cos-lite",
        channel=channel,
        trust=True,
        overlays=[str(get_this_script_dir() / "offers-overlay.yaml")],
    )


async def _deploy_hardware_observer(series, channel, model):
    """Deploy Hardware Observer and Grafana Agent on the existing lxd cloud."""
    await asyncio.gather(
        # Principal Ubuntu
        model.deploy(
            "ubuntu",
            num_units=1,
            series=series,
            channel=channel,
        ),
        # Hardware Observer
        model.deploy("hardware-observer", series=series, num_units=0, channel=channel),
        # Grafana Agent
        model.deploy(
            "grafana-agent",
            num_units=0,
            series=series,
            channel=channel,
        ),
    )

    await model.add_relation("ubuntu:juju-info", "hardware-observer:general-info")
    await model.add_relation("hardware-observer:cos-agent", "grafana-agent:cos-agent")
    await model.add_relation("ubuntu:juju-info", "grafana-agent:juju-info")
    await model.block_until(lambda: len(model.applications["hardware-observer"].units) > 0)


async def _add_cross_controller_relations(k8s_ctl, lxd_ctl, k8s_mdl, lxd_mdl):
    """Add relations between Grafana Agent and COS."""
    cos_saas_names = ["prometheus-receive-remote-write", "loki-logging", "grafana-dashboards"]
    for saas in cos_saas_names:
        # Using juju cli since Model.consume() from libjuju causes error.
        # https://github.com/juju/python-libjuju/issues/1031
        cmd = [
            "juju",
            "consume",
            "--model",
            f"{lxd_ctl.controller_name}:{k8s_mdl.name}",
            f"{k8s_ctl.controller_name}:admin/{k8s_mdl.name}.{saas}",
        ]
        subprocess.run(cmd, check=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        await lxd_mdl.add_relation("grafana-agent", saas),

    # `idle_period` needs to be greater than the scrape interval to make sure metrics ingested.
    await asyncio.gather(
        # First, we wait for the critical phase to pass with raise_on_error=False.
        # (In CI, using github runners, we often see unreproducible hook failures.)
        lxd_mdl.wait_for_idle(timeout=1800, idle_period=180, raise_on_error=False),
        k8s_mdl.wait_for_idle(timeout=1800, idle_period=180, raise_on_error=False),
    )

    await asyncio.gather(
        # Then we wait for "active", without raise_on_error=False, so the test fails sooner in case
        # there is a persistent error status.
        lxd_mdl.wait_for_idle(status="active", timeout=7200, idle_period=180),
        k8s_mdl.wait_for_idle(status="active", timeout=7200, idle_period=180),
    )
